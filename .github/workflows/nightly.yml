name: nightly build

on:
  push:
    branches:
      - dev

env:
  DOCKER_INTERMEDIATE_REPO: "nwodtuhs/exegol-builds"
  DOCKER_PROD_REPO: "nwodtuhs/exegol-dev"
  IMAGE_BASE_NAME: "nightly"
  DOCKERFILE: "./Dockerfile"

jobs:
  amd64_buildx:
    timeout-minutes: 360
    runs-on: [ self-hosted, amd64 ]
    outputs:
      matrix_p1: ${{ steps.set-matrix.outputs.matrix_p1 }}
      matrix_p2: ${{ steps.set-matrix.outputs.matrix_p2 }}
      matrix_p3: ${{ steps.set-matrix.outputs.matrix_p3 }}
      matrix_p4: ${{ steps.set-matrix.outputs.matrix_p4 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Prepare build
        id: prepare_build
        run: |
          IMAGE_NAME="${IMAGE_BASE_NAME}-amd64"
          DOCKER_REPO=${DOCKER_INTERMEDIATE_REPO}
          COMMIT_ID=$(git rev-parse "$GITHUB_SHA")
          IMAGE_VERSION=${COMMIT_ID:0:8}
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "image_repo=${DOCKER_REPO}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_full_name=${DOCKER_REPO}:${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_version=${IMAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2
      - name: Build and load the image
        if: success()
        uses: docker/build-push-action@v3
        with:
          load: true
          build-args: |
            TAG=${{ env.IMAGE_BASE_NAME }}
            VERSION=${{ steps.prepare_build.outputs.image_version }}
            BUILD_DATE=${{ steps.prepare_build.outputs.build_date }}
          tags: ${{ steps.prepare_build.outputs.image_full_name }}
          platforms: linux/amd64
          file: ${{env.DOCKERFILE}}
          context: .
      - name: Login to Dockerhub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Push docker image
        run: docker push ${{ steps.prepare_build.outputs.image_full_name }}
      - name: List available tests
        id: set-matrix
        run: |
          ID=$(docker run --rm -t -d ${{ steps.prepare_build.outputs.image_full_name }} endless)
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/all_commands.txt | sort -u > /.exegol/build_pipeline_tests/all_commands.sorted.txt'
          line_count=$(docker exec $ID zsh -c 'wc -l /.exegol/build_pipeline_tests/all_commands.sorted.txt | cut -d " " -f 1')
          echo "$line_count test commands found!"
          if [ $line_count -lt 1000 ]; then
            echo "matrix_p1=$(docker exec $ID zsh -c 'head /.exegol/build_pipeline_tests/all_commands.sorted.txt -n 250' | grep -vE '^\s*$' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p2=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +251 | head -n 250' | grep -vE '^\s*$' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p3=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +501 | head -n 250' | grep -vE '^\s*$' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p4=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +751 | head -n 250' | grep -vE '^\s*$' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            return_code=0
          else
            echo "Too many command to test! (${line_count}/1000)"
            echo "Maximum of 250 tests per matrix."
            return_code=1
          fi
          docker stop $ID
          exit $return_code
  amd64_t1:
    needs: amd64_buildx
    if: ${{ needs.amd64_buildx.outputs.matrix_p1 != '[]' && needs.amd64_buildx.outputs.matrix_p1 != '' }}
    runs-on: [ self-hosted, amd64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.amd64_buildx.outputs.matrix_p1) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          image_name="${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-amd64"
          echo -e "\nUsing image $image_name in version $(docker image inspect --format='{{index .Config.Labels "org.exegol.version"}} ({{index .Id}})' $image_name)\n"
          echo "$ ${COMMAND}"
          docker run --rm --env "DISABLE_AUTO_UPDATE=true" --env CMD="$COMMAND" $image_name cmd zsh -c 'autoload -Uz compinit; compinit; source ~/.zshrc; eval $CMD'
  amd64_t2:
    needs: amd64_buildx
    if: ${{ needs.amd64_buildx.outputs.matrix_p2 != '[]' && needs.amd64_buildx.outputs.matrix_p2 != '' }}
    runs-on: [ self-hosted, amd64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.amd64_buildx.outputs.matrix_p2) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          image_name="${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-amd64"
          echo -e "\nUsing image $image_name in version $(docker image inspect --format='{{index .Config.Labels "org.exegol.version"}} ({{index .Id}})' $image_name)\n"
          echo "$ ${COMMAND}"
          docker run --rm --env "DISABLE_AUTO_UPDATE=true" --env CMD="$COMMAND" $image_name cmd zsh -c 'autoload -Uz compinit; compinit; source ~/.zshrc; eval $CMD'
  amd64_t3:
    needs: amd64_buildx
    if: ${{ needs.amd64_buildx.outputs.matrix_p3 != '[]' && needs.amd64_buildx.outputs.matrix_p3 != '' }}
    runs-on: [ self-hosted, amd64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.amd64_buildx.outputs.matrix_p3) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          image_name="${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-amd64"
          echo -e "\nUsing image $image_name in version $(docker image inspect --format='{{index .Config.Labels "org.exegol.version"}} ({{index .Id}})' $image_name)\n"
          echo "$ ${COMMAND}"
          docker run --rm --env "DISABLE_AUTO_UPDATE=true" --env CMD="$COMMAND" $image_name cmd zsh -c 'autoload -Uz compinit; compinit; source ~/.zshrc; eval $CMD'
  amd64_t4:
    needs: amd64_buildx
    if: ${{ needs.amd64_buildx.outputs.matrix_p4 != '[]' && needs.amd64_buildx.outputs.matrix_p4 != '' }}
    runs-on: [ self-hosted, amd64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.amd64_buildx.outputs.matrix_p4) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          image_name="${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-amd64"
          echo -e "\nUsing image $image_name in version $(docker image inspect --format='{{index .Config.Labels "org.exegol.version"}} ({{index .Id}})' $image_name)\n"
          echo "$ ${COMMAND}"
          docker run --rm --env "DISABLE_AUTO_UPDATE=true" --env CMD="$COMMAND" $image_name cmd zsh -c 'autoload -Uz compinit; compinit; source ~/.zshrc; eval $CMD'

  amd64_clean:
    needs:
      - amd64_t1
      - amd64_t2
      - amd64_t3
      - amd64_t4
    runs-on: [ self-hosted, amd64 ]
    if: always()  # always mode clean the environment even when the task is cancelled by a user
    steps:
      - name: Clean unused dangling images
        run: docker image prune --filter "label=org.exegol.app=Exegol" --force

  arm64_buildx:
    timeout-minutes: 360
    runs-on: [ self-hosted, arm64 ]
    outputs:
      matrix_p1: ${{ steps.set-matrix.outputs.matrix_p1 }}
      matrix_p2: ${{ steps.set-matrix.outputs.matrix_p2 }}
      matrix_p3: ${{ steps.set-matrix.outputs.matrix_p3 }}
      matrix_p4: ${{ steps.set-matrix.outputs.matrix_p4 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Prepare build
        id: prepare_build
        run: |
          IMAGE_NAME="${IMAGE_BASE_NAME}-arm64"
          DOCKER_REPO=${DOCKER_INTERMEDIATE_REPO}
          COMMIT_ID=$(git rev-parse "$GITHUB_SHA")
          IMAGE_VERSION=${COMMIT_ID:0:8}
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "image_repo=${DOCKER_REPO}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_full_name=${DOCKER_REPO}:${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_version=${IMAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2
      - name: Build and load the image
        if: success()
        uses: docker/build-push-action@v3
        with:
          load: true
          build-args: |
            TAG=${{ env.IMAGE_BASE_NAME }}
            VERSION=${{ steps.prepare_build.outputs.image_version }}
            BUILD_DATE=${{ steps.prepare_build.outputs.build_date }}
          tags: ${{ steps.prepare_build.outputs.image_full_name }}
          platforms: linux/arm64
          file: ${{env.DOCKERFILE}}
          context: .
      - name: Login to Dockerhub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Push docker image
        run: docker push ${{ steps.prepare_build.outputs.image_full_name }}
      - name: List available tests
        id: set-matrix
        run: |
          ID=$(docker run --rm -t -d ${{ steps.prepare_build.outputs.image_full_name }} endless)
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/all_commands.txt | sort -u > /.exegol/build_pipeline_tests/all_commands.sorted.txt'
          line_count=$(docker exec $ID zsh -c 'wc -l /.exegol/build_pipeline_tests/all_commands.sorted.txt | cut -d " " -f 1')
          echo "$line_count test commands found!"
          if [ $line_count -lt 1000 ]; then
            echo "matrix_p1=$(docker exec $ID zsh -c 'head /.exegol/build_pipeline_tests/all_commands.sorted.txt -n 250' | grep -vE '^\s*$' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p2=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +251 | head -n 250' | grep -vE '^\s*$' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p3=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +501 | head -n 250' | grep -vE '^\s*$' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p4=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +751 | head -n 250' | grep -vE '^\s*$' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            return_code=0
          else
            echo "Too many command to test! (${line_count}/1000)"
            echo "Maximum of 250 tests per matrix."
            return_code=1
          fi
          docker stop $ID
          exit $return_code

  arm64_t1:
    needs: arm64_buildx
    if: ${{ needs.arm64_buildx.outputs.matrix_p1 != '[]' && needs.arm64_buildx.outputs.matrix_p1 != '' }}
    runs-on: [ self-hosted, arm64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.arm64_buildx.outputs.matrix_p1) }}
    steps:
# Step for multi-runner tests (add a specific tag on arm32 runner dedicated / available for tests)
#      - name: Login to Dockerhub
#        uses: docker/login-action@v2
#        with:
#          username: ${{ secrets.DOCKER_USERNAME }}
#          password: ${{ secrets.DOCKER_PASSWORD }}
#      - name: Force update local image
#        run: |
#          image_name="${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64"
#          docker pull $image_name
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          image_name="${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64"
          echo -e "\nUsing image $image_name in version $(docker image inspect --format='{{index .Config.Labels "org.exegol.version"}} ({{index .Id}})' $image_name)\n"
          echo "$ ${COMMAND}"
          docker run --rm --env "DISABLE_AUTO_UPDATE=true" --env CMD="$COMMAND" $image_name cmd zsh -c 'autoload -Uz compinit; compinit; source ~/.zshrc; eval $CMD'
  arm64_t2:
    needs: arm64_buildx
    if: ${{ needs.arm64_buildx.outputs.matrix_p2 != '[]' && needs.arm64_buildx.outputs.matrix_p2 != '' }}
    runs-on: [ self-hosted, arm64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.arm64_buildx.outputs.matrix_p2) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          image_name="${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64"
          echo -e "\nUsing image $image_name in version $(docker image inspect --format='{{index .Config.Labels "org.exegol.version"}} ({{index .Id}})' $image_name)\n"
          echo "$ ${COMMAND}"
          docker run --rm --env "DISABLE_AUTO_UPDATE=true" --env CMD="$COMMAND" $image_name cmd zsh -c 'autoload -Uz compinit; compinit; source ~/.zshrc; eval $CMD'
  arm64_t3:
    needs: arm64_buildx
    if: ${{ needs.arm64_buildx.outputs.matrix_p3 != '[]' && needs.arm64_buildx.outputs.matrix_p3 != '' }}
    runs-on: [ self-hosted, arm64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.arm64_buildx.outputs.matrix_p3) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          image_name="${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64"
          echo -e "\nUsing image $image_name in version $(docker image inspect --format='{{index .Config.Labels "org.exegol.version"}} ({{index .Id}})' $image_name)\n"
          echo "$ ${COMMAND}"
          docker run --rm --env "DISABLE_AUTO_UPDATE=true" --env CMD="$COMMAND" $image_name cmd zsh -c 'autoload -Uz compinit; compinit; source ~/.zshrc; eval $CMD'
  arm64_t4:
    needs: arm64_buildx
    if: ${{ needs.arm64_buildx.outputs.matrix_p4 != '[]' && needs.arm64_buildx.outputs.matrix_p4 != '' }}
    runs-on: [ self-hosted, arm64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.arm64_buildx.outputs.matrix_p4) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          image_name="${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64"
          echo -e "\nUsing image $image_name in version $(docker image inspect --format='{{index .Config.Labels "org.exegol.version"}} ({{index .Id}})' $image_name)\n"
          echo "$ ${COMMAND}"
          docker run --rm --env "DISABLE_AUTO_UPDATE=true" --env CMD="$COMMAND" $image_name cmd zsh -c 'autoload -Uz compinit; compinit; source ~/.zshrc; eval $CMD'

  arm64_clean:
    needs:
      - arm64_t1
      - arm64_t2
      - arm64_t3
      - arm64_t4
    runs-on: [ self-hosted, arm64 ]
    if: always()  # always mode clean the environment even when the task is cancelled by a user
    steps:
      - name: Clean unused dangling images
        run: docker image prune --filter "label=org.exegol.app=Exegol" --force

  manifest_build:
    timeout-minutes: 60
    needs:
      - amd64_t1
      - amd64_t2
      - amd64_t3
      - amd64_t4
      - arm64_t1
      - arm64_t2
      - arm64_t3
      - arm64_t4
    runs-on: self-hosted
    if: ${{ always() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
    steps:
      - name: Login to Dockerhub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Create and push manifest
        if: success()
        run: |
          docker manifest create ${DOCKER_PROD_REPO}:${IMAGE_BASE_NAME} ${DOCKER_INTERMEDIATE_REPO}:${IMAGE_BASE_NAME}-arm64 ${DOCKER_INTERMEDIATE_REPO}:${IMAGE_BASE_NAME}-amd64
          docker manifest push ${DOCKER_PROD_REPO}:${IMAGE_BASE_NAME}
          docker manifest rm ${DOCKER_PROD_REPO}:${IMAGE_BASE_NAME}
      - name: Remove intermediate images
        run: |
          HUB_TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d "{\"username\": \"${{ secrets.DOCKER_USERNAME }}\", \"password\": \"${{ secrets.DOCKER_PASSWORD }}\"}" https://hub.docker.com/v2/users/login/ | jq -r .token)
          curl -i -X DELETE -H "Accept: application/json" -H "Authorization: JWT $HUB_TOKEN" https://hub.docker.com/v2/repositories/${DOCKER_INTERMEDIATE_REPO}/tags/${IMAGE_BASE_NAME}-arm64/
          curl -i -X DELETE -H "Accept: application/json" -H "Authorization: JWT $HUB_TOKEN" https://hub.docker.com/v2/repositories/${DOCKER_INTERMEDIATE_REPO}/tags/${IMAGE_BASE_NAME}-amd64/
